from sklearn import metrics
import networkx as nx
import numpy as np
import scipy.spatial as spt
from scipy.stats import rankdata

# Modified NetworkX MST implementation
# import customMST
import igraph

# Add a try except for igraph?

def compDists(data1,data2):
	'''
	Compute distances between two datasets. Usually the same dataset will be passed as data1 and data2
	as we wish to get the dissimilarity matrix of the dataset

	:return: Distance array (or dissimilarity matrix) of the data
	'''
	return metrics.pairwise.euclidean_distances(data1, data2)
	
def compDists_sp(data):
	'''
	Compute distances between two datasets. Usually the same dataset will be passed as data1 and data2
	as we wish to get the dissimilarity matrix of the dataset

	:return: Distance array (or dissimilarity matrix) of the data
	'''
	# Some say this should be faster, but hasn't really found to be
	# May be more memory efficient, so perhaps try this is that is a problem
	# Perhaps try except for a memory error could do the job?
	return spt.distance.squareform(spt.distance.pdist(data,'euclidean'))

def createMST_nx(distarray):
	'''
	Creates the MST from the distance array, using a customised NetworkX MST implementation
	:param distarray: Distance array (generated by compDists())
	:return: Returns the MST (graph, default from nx) and edgelist (from customisation)
	'''
	G = nx.from_numpy_matrix(distarray)
	mst, edgelist = customMST.minimum_spanning_tree(G, algorithm='prim')
	# edgelist = customMST.minimum_spanning_tree(G, algorithm='prim')
	return mst, edgelist

def createMST(distarray):
	# Create directed, weighted graph (loops=False means ignore diagonal)
	G = igraph.Graph.Weighted_Adjacency(distarray.tolist(), mode="DIRECTED", loops=False)

	# Get the MST
	# Does not randomise starting node
	mst_ig = igraph.Graph.spanning_tree(G, weights=G.es["weight"], return_tree=False)
	# mst_ig2 = igraph.Graph.spanning_tree(G, weights=G.es["weight"], return_tree=True)

	# print(mst_ig2)

	# for edge in mst_ig2.es:
	# 	print(edge.tuple)

	# Create an array of infinities, so we get an error if we miss something!
	# We have one more vertex than edges, so +1
	gen_ig = np.full(len(mst_ig)+1, np.inf)

	# The below is MOSTLY equivalent to a Python version of Mario's code
	# Differences seem minor
	for i, edge in enumerate(mst_ig):
		edge_tup = G.es[edge].tuple

		# print(edge_tup, G.es[edge].source, G.es[edge].target)
		if np.isinf(gen_ig[edge_tup[1]]):
			gen_ig[edge_tup[1]] = edge_tup[0]
			# print("Normal:",edge_tup)
		else:
			gen_ig[edge_tup[0]] = edge_tup[1]
			# print("Else:",edge_tup)

	# As there is one more vertex than edge, find and fill in the missing one
	if np.isinf(gen_ig).any():
		index = np.where(np.isinf(gen_ig))[0][0]
		gen_ig[index] = np.where(gen_ig == index)[0][0]
		
	# Cast types to integers
	gen_ig = gen_ig.astype(int)

	# print(gen_ig)

	## The below is for error checking
	H = igraph.Graph()
	H.add_vertices(len(gen_ig))
	H.add_edges([(index,edge) for index,edge in enumerate(gen_ig)])
	# Check we have a single connected component
	assert len(H.components(mode="WEAK")) == 1

	# Return as a list
	return gen_ig.tolist()

def normaliseDistArray(distarray):
	max_val = np.max(distarray)
	min_val = np.min(distarray)
	denom = max_val - min_val

	for row, val in enumerate(distarray):
		distarray[row] = (val - min_val)/denom
	return distarray

def degreeInterest(mst_genotype, L, nn_rankings, distarray):
	return [min(nn_rankings[i][j],nn_rankings[j][i])+distarray[i][j] for i,j in enumerate(mst_genotype)]

def interestLinksIndices(degree_int):
	'''
	Argsort the degree of interestingness list to get the indices of the most interesting links first

	Notes:
	Merge sort is stable and gives better ordering
	We use negative so that the lower indices appear first in the list

	:param degree_int: Degree of interestingness for each link in MST
	:return: Indices of most interesting links, in order of most to last (i.e. last is 0, as it connects to itself
			 and will be the least interesting link)
	'''
	return np.argsort(-(np.asarray(degree_int)), kind='mergesort').tolist()

def LARfromMST(edgelist, mst):
	'''
	Convert the MST into a locus-based adjacency representation/encoding

	:param edgelist: Edgelist of the MST
	:param mst: The MST
	:return: A list in the format of a locus-based adjacency genotype
	'''
	# Initialise an array of the right length (number of nodes in the MST)
	indiv_array = np.zeros(len(list(mst.nodes())),).astype(int)

	# We first connect the first data item with itself
	# As the MST has one fewer edge than nodes, but LAR is of length #nodes
	indiv_array[0] = 0
	for edge in edgelist:
		indiv_array[edge[0]] = edge[1]
	return indiv_array.tolist()

def decodingLAR(indiv):
	g = igraph.Graph()
	g.add_vertices(len(indiv))
	g.add_edges(zip(range(len(indiv)),indiv))
	return list(g.components(mode="WEAK"))

def nnRankings(distarray, num_examples):
	nn_rankings = np.zeros((num_examples,num_examples),dtype=int)
	for i, row in enumerate(distarray):
		nn_rankings[i] = rankdata(row, method='ordinal')-1 # minus 1 so that 0 rank is itself
	return nn_rankings